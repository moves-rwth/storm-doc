<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Storm: storm::solver::helper::ValueIterationOperator&lt; ValueType, TrivialRowGrouping, SolutionType &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Storm<span id="projectnumber">&#160;1.11.1.1</span>
   </div>
   <div id="projectbrief">A Modern Probabilistic Model Checker</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../de/d69/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">storm::solver::helper::ValueIterationOperator&lt; ValueType, TrivialRowGrouping, SolutionType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class represents the Value Iteration Operator (also known as Bellman operator).  
 <a href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa78fee5a6b89fae50c7f0e9448db42f6" id="r_aa78fee5a6b89fae50c7f0e9448db42f6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> = <a class="el" href="../../d2/d5a/namespacestorm_1_1storage_1_1sparse.html#afee8537610fbb8da6f30890d6a231399">storm::storage::sparse::state_type</a></td></tr>
<tr class="separator:aa78fee5a6b89fae50c7f0e9448db42f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35e078e6f5a0b1de8d1c3c76961d5644" id="r_a35e078e6f5a0b1de8d1c3c76961d5644"><td class="memTemplParams" colspan="2">template&lt;bool Backward = true&gt; </td></tr>
<tr class="memitem:a35e078e6f5a0b1de8d1c3c76961d5644"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a35e078e6f5a0b1de8d1c3c76961d5644">setMatrix</a> (<a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;matrix, std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *rowGroupIndices=nullptr)</td></tr>
<tr class="memdesc:a35e078e6f5a0b1de8d1c3c76961d5644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this operator with the given data.  <br /></td></tr>
<tr class="separator:a35e078e6f5a0b1de8d1c3c76961d5644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add674a660401f13ebe53a94d1e6841b3" id="r_add674a660401f13ebe53a94d1e6841b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#add674a660401f13ebe53a94d1e6841b3">setMatrixForwards</a> (<a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;matrix, std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *rowGroupIndices=nullptr)</td></tr>
<tr class="memdesc:add674a660401f13ebe53a94d1e6841b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this operator with the given data for forward iterations (starting with the smallest row group.  <br /></td></tr>
<tr class="separator:add674a660401f13ebe53a94d1e6841b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade33f7294424f5df3d57d4b3b2a5bc75" id="r_ade33f7294424f5df3d57d4b3b2a5bc75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#ade33f7294424f5df3d57d4b3b2a5bc75">setMatrixBackwards</a> (<a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;matrix, std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *rowGroupIndices=nullptr)</td></tr>
<tr class="memdesc:ade33f7294424f5df3d57d4b3b2a5bc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this operator with the given data for backward iterations (starting with the largest row group)  <br /></td></tr>
<tr class="separator:ade33f7294424f5df3d57d4b3b2a5bc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2b6feab3710c0181082da976a3e90b" id="r_a9f2b6feab3710c0181082da976a3e90b"><td class="memTemplParams" colspan="2">template&lt;typename OperandType , typename OffsetType , typename BackendType &gt; </td></tr>
<tr class="memitem:a9f2b6feab3710c0181082da976a3e90b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a9f2b6feab3710c0181082da976a3e90b">apply</a> (OperandType const &amp;operandIn, OperandType &amp;operandOut, OffsetType const &amp;offsets, BackendType &amp;backend) const</td></tr>
<tr class="memdesc:a9f2b6feab3710c0181082da976a3e90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the operator with the given operands, offsets, and backend.  <br /></td></tr>
<tr class="separator:a9f2b6feab3710c0181082da976a3e90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b01b9b775d21d8b8018eb257306dce" id="r_a32b01b9b775d21d8b8018eb257306dce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../df/ddc/namespacestorm_1_1solver.html#af4adb01eeae9baf8f54b159cb43aaa39">OptimizationDirection</a> RobustDir, typename OperandType , typename OffsetType , typename BackendType &gt; </td></tr>
<tr class="memitem:a32b01b9b775d21d8b8018eb257306dce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a32b01b9b775d21d8b8018eb257306dce">applyRobust</a> (OperandType const &amp;operandIn, OperandType &amp;operandOut, OffsetType const &amp;offsets, BackendType &amp;backend) const</td></tr>
<tr class="separator:a32b01b9b775d21d8b8018eb257306dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad388d98739b02e1f65bd72b6f70cd7db" id="r_ad388d98739b02e1f65bd72b6f70cd7db"><td class="memTemplParams" colspan="2">template&lt;typename OperandType , typename OffsetType , typename BackendType &gt; </td></tr>
<tr class="memitem:ad388d98739b02e1f65bd72b6f70cd7db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#ad388d98739b02e1f65bd72b6f70cd7db">applyInPlace</a> (OperandType &amp;operand, OffsetType const &amp;offsets, BackendType &amp;backend) const</td></tr>
<tr class="memdesc:ad388d98739b02e1f65bd72b6f70cd7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>apply</code> but with operandOut==operandIn.  <br /></td></tr>
<tr class="separator:ad388d98739b02e1f65bd72b6f70cd7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573a74e955b6074608cac8e33f94a778" id="r_a573a74e955b6074608cac8e33f94a778"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="../../df/ddc/namespacestorm_1_1solver.html#af4adb01eeae9baf8f54b159cb43aaa39">OptimizationDirection</a> RobustDir, typename OperandType , typename OffsetType , typename BackendType &gt; </td></tr>
<tr class="memitem:a573a74e955b6074608cac8e33f94a778"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a573a74e955b6074608cac8e33f94a778">applyInPlaceRobust</a> (OperandType &amp;operand, OffsetType const &amp;offsets, BackendType &amp;backend) const</td></tr>
<tr class="separator:a573a74e955b6074608cac8e33f94a778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260bb928cce77534a04c9e5dab1c623a" id="r_a260bb928cce77534a04c9e5dab1c623a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a260bb928cce77534a04c9e5dab1c623a">setIgnoredRows</a> (bool useLocalRowIndices, std::function&lt; bool(<a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a>, <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a>)&gt; const &amp;ignore)</td></tr>
<tr class="memdesc:a260bb928cce77534a04c9e5dab1c623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets rows that will be skipped when applying the operator.  <br /></td></tr>
<tr class="separator:a260bb928cce77534a04c9e5dab1c623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24153a9da75f8b3898825fa3a3192099" id="r_a24153a9da75f8b3898825fa3a3192099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a24153a9da75f8b3898825fa3a3192099">unsetIgnoredRows</a> ()</td></tr>
<tr class="memdesc:a24153a9da75f8b3898825fa3a3192099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all ignored rows.  <br /></td></tr>
<tr class="separator:a24153a9da75f8b3898825fa3a3192099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d60a651e8c293c941669c269c3da4d" id="r_a34d60a651e8c293c941669c269c3da4d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a34d60a651e8c293c941669c269c3da4d">getRowGroupIndices</a> () const</td></tr>
<tr class="separator:a34d60a651e8c293c941669c269c3da4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a244df3fbb78b289734520ecd0008b" id="r_a19a244df3fbb78b289734520ecd0008b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; SolutionType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a19a244df3fbb78b289734520ecd0008b">allocateAuxiliaryVector</a> (uint64_t size, std::optional&lt; SolutionType &gt; const &amp;initialValue={})</td></tr>
<tr class="memdesc:a19a244df3fbb78b289734520ecd0008b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates additional storage that can be used e.g.  <br /></td></tr>
<tr class="separator:a19a244df3fbb78b289734520ecd0008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f240dbaea2c88b0350f283fab00e88" id="r_a45f240dbaea2c88b0350f283fab00e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#a45f240dbaea2c88b0350f283fab00e88">freeAuxiliaryVector</a> ()</td></tr>
<tr class="memdesc:a45f240dbaea2c88b0350f283fab00e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the auxiliary vector, invalidating any references to it.  <br /></td></tr>
<tr class="separator:a45f240dbaea2c88b0350f283fab00e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename ValueType, bool TrivialRowGrouping, typename SolutionType&gt;<br />
class storm::solver::helper::ValueIterationOperator&lt; ValueType, TrivialRowGrouping, SolutionType &gt;</div><p>This class represents the Value Iteration Operator (also known as Bellman operator). </p>
<p>It is tailored for efficiency, in particular when applied multiple times. The application of the operator is heavily templated so that many different flavours of value iteration and related algorithms can be implemented using this. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the matrix entries </td></tr>
    <tr><td class="paramname">TrivialRowGrouping</td><td>True iff the underlying model is deterministic </td></tr>
    <tr><td class="paramname">SolutionType</td><td>The type of the operand entries. Default is ValueType, see <a class="el" href="../../d9/d41/_value_iteration_operator_forward_8h.html">ValueIterationOperatorForward.h</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00039">39</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa78fee5a6b89fae50c7f0e9448db42f6" name="aa78fee5a6b89fae50c7f0e9448db42f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78fee5a6b89fae50c7f0e9448db42f6">&#9670;&#160;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::IndexType =  <a class="el" href="../../d2/d5a/namespacestorm_1_1storage_1_1sparse.html#afee8537610fbb8da6f30890d6a231399">storm::storage::sparse::state_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00041">41</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a19a244df3fbb78b289734520ecd0008b" name="a19a244df3fbb78b289734520ecd0008b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a244df3fbb78b289734520ecd0008b">&#9670;&#160;</a></span>allocateAuxiliaryVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; SolutionType &gt; &amp; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::allocateAuxiliaryVector </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; SolutionType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates additional storage that can be used e.g. </p>
<p>when applying the operand </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size of the auxiliary vector </td></tr>
    <tr><td class="paramname">initialValue</td><td>optional initial value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the auxiliary vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00152">152</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="a9f2b6feab3710c0181082da976a3e90b" name="a9f2b6feab3710c0181082da976a3e90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2b6feab3710c0181082da976a3e90b">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
<div class="memtemplate">
template&lt;typename OperandType , typename OffsetType , typename BackendType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">OperandType const &amp;&#160;</td>
          <td class="paramname"><em>operandIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OperandType &amp;&#160;</td>
          <td class="paramname"><em>operandOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetType const &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackendType &amp;&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the operator with the given operands, offsets, and backend. </p>
<p>More specifically, for each row group and for each row in a row group, this multiplies the matrix row with the given input operand vector and adds the offset row entry. The backend is invoked with row results and&mdash;once all rows in a group are processed&mdash;assigns the new row group value to the output operand. The following backend methods are invoked:</p><ul>
<li>backend.startNewIteration(); at the beginning of each call to <code>apply</code></li>
<li>backend.firstRow(rowResult, rowGroupIndex, rowIndex); once the first row of a row group is processed</li>
<li>backend.nextRow(rowResult, rowGroupIndex, rowIndex); for the subsequent rows of a row group (not invoked if TrivialRowGrouping)</li>
<li>backend.applyUpdate(operandOutReference, rowGroupIndex); once all rows of a group are processed. Here, the backend can set the result value for the row group to the first argument</li>
<li>backend.abort(); invoked after a group is processed. If this returns true, the method is aborted, even if some groups have not been processed yet</li>
<li>backend.endOfIteration(); invoked when all groups are processed</li>
<li>backend.converged(); invoked when abort() returns true or all groups are processed. Determines the return value of this method</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OperandType</td><td>The type of input and output operand. Can be a value vector or a pair of two value vectors with one entry per group. In the latter case, the rowResult for backend.firstRow and backend.nextRow is a pair of values and applyUpdate gets two operandOutReference's to write the group result to. </td></tr>
    <tr><td class="paramname">OffsetType</td><td>The type of row offsets. Can be a single value vector (one entry per row) or a pair of a (pointer to a) value vector and a value. The latter case is only valid if OperandType is a pair of two value vectors. </td></tr>
    <tr><td class="paramname">BackendType</td><td>The type of backend, shall implement the methods above </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operandIn</td><td>Input operand </td></tr>
    <tr><td class="paramname">operandOut</td><td>Output operand </td></tr>
    <tr><td class="paramname">offsets</td><td>Row offsets which are added to each row result </td></tr>
    <tr><td class="paramname">backend</td><td>the backend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever backend.converged() returns</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This and other apply methods are intentionally implemented in the header file as there are potentially many different BackendTypes </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00099">99</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>

</div>
</div>
<a id="ad388d98739b02e1f65bd72b6f70cd7db" name="ad388d98739b02e1f65bd72b6f70cd7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad388d98739b02e1f65bd72b6f70cd7db">&#9670;&#160;</a></span>applyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
<div class="memtemplate">
template&lt;typename OperandType , typename OffsetType , typename BackendType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::applyInPlace </td>
          <td>(</td>
          <td class="paramtype">OperandType &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetType const &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackendType &amp;&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code>apply</code> but with operandOut==operandIn. </p>

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00125">125</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>

</div>
</div>
<a id="a573a74e955b6074608cac8e33f94a778" name="a573a74e955b6074608cac8e33f94a778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573a74e955b6074608cac8e33f94a778">&#9670;&#160;</a></span>applyInPlaceRobust()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="../../df/ddc/namespacestorm_1_1solver.html#af4adb01eeae9baf8f54b159cb43aaa39">OptimizationDirection</a> RobustDir, typename OperandType , typename OffsetType , typename BackendType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::applyInPlaceRobust </td>
          <td>(</td>
          <td class="paramtype">OperandType &amp;&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetType const &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackendType &amp;&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00130">130</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>

</div>
</div>
<a id="a32b01b9b775d21d8b8018eb257306dce" name="a32b01b9b775d21d8b8018eb257306dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b01b9b775d21d8b8018eb257306dce">&#9670;&#160;</a></span>applyRobust()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="../../df/ddc/namespacestorm_1_1solver.html#af4adb01eeae9baf8f54b159cb43aaa39">OptimizationDirection</a> RobustDir, typename OperandType , typename OffsetType , typename BackendType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::applyRobust </td>
          <td>(</td>
          <td class="paramtype">OperandType const &amp;&#160;</td>
          <td class="paramname"><em>operandIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OperandType &amp;&#160;</td>
          <td class="paramname"><em>operandOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetType const &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BackendType &amp;&#160;</td>
          <td class="paramname"><em>backend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html#l00105">105</a> of file <a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a>.</p>

</div>
</div>
<a id="a45f240dbaea2c88b0350f283fab00e88" name="a45f240dbaea2c88b0350f283fab00e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f240dbaea2c88b0350f283fab00e88">&#9670;&#160;</a></span>freeAuxiliaryVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::freeAuxiliaryVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the auxiliary vector, invalidating any references to it. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00165">165</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="a34d60a651e8c293c941669c269c3da4d" name="a34d60a651e8c293c941669c269c3da4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d60a651e8c293c941669c269c3da4d">&#9670;&#160;</a></span>getRowGroupIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;<a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">::IndexType</a> &gt; const  &amp; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::getRowGroupIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The considered row group indices </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00146">146</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="a260bb928cce77534a04c9e5dab1c623a" name="a260bb928cce77534a04c9e5dab1c623a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260bb928cce77534a04c9e5dab1c623a">&#9670;&#160;</a></span>setIgnoredRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::setIgnoredRows </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLocalRowIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a>, <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a>)&gt; const &amp;&#160;</td>
          <td class="paramname"><em>ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets rows that will be skipped when applying the operator. </p>
<dl class="section note"><dt>Note</dt><dd>each row group shall have at least one row that is not ignored </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useLocalRowIndices</td><td>if true, the row indices are considered to be local to the group, i.e. row i is the i'th row in the given group if false, row indices are global, i.e. row i refers to the i'th row of the entire matrix </td></tr>
    <tr><td class="paramname">ignore</td><td>function object that takes a row group index and a row index and returns true, iff the corresponding row shall be skipped </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00135">135</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="a35e078e6f5a0b1de8d1c3c76961d5644" name="a35e078e6f5a0b1de8d1c3c76961d5644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e078e6f5a0b1de8d1c3c76961d5644">&#9670;&#160;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
<div class="memtemplate">
template&lt;bool Backward&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::setMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *&#160;</td>
          <td class="paramname"><em>rowGroupIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this operator with the given data. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">backwards</td><td>if true, we iterate backwards starting with the largest rowgroup. This often makes in place (Gauss-Seidel) iterations more efficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the transition matrix </td></tr>
    <tr><td class="paramname">rowGroupIndices</td><td>if given, overwrites the rowGroupIndices of the matrix. Must be nullptr if TrivialRowGrouping is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The reference to the row group indices (either of the matrix or the given pointer) must not be invalidated as long as this operator is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00013">13</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="ade33f7294424f5df3d57d4b3b2a5bc75" name="ade33f7294424f5df3d57d4b3b2a5bc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade33f7294424f5df3d57d4b3b2a5bc75">&#9670;&#160;</a></span>setMatrixBackwards()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::setMatrixBackwards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *&#160;</td>
          <td class="paramname"><em>rowGroupIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this operator with the given data for backward iterations (starting with the largest row group) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the transition matrix </td></tr>
    <tr><td class="paramname">rowGroupIndices</td><td>if given, overwrites the rowGroupIndices of the matrix. Must be nullptr if TrivialRowGrouping is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The reference to the row group indices (either of the matrix or the given pointer) must not be invalidated as long as this operator is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00088">88</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="add674a660401f13ebe53a94d1e6841b3" name="add674a660401f13ebe53a94d1e6841b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add674a660401f13ebe53a94d1e6841b3">&#9670;&#160;</a></span>setMatrixForwards()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::setMatrixForwards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/df0/classstorm_1_1storage_1_1_sparse_matrix.html">storm::storage::SparseMatrix</a>&lt; ValueType &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html#aa78fee5a6b89fae50c7f0e9448db42f6">IndexType</a> &gt; const *&#160;</td>
          <td class="paramname"><em>rowGroupIndices</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this operator with the given data for forward iterations (starting with the smallest row group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>the transition matrix </td></tr>
    <tr><td class="paramname">rowGroupIndices</td><td>if given, overwrites the rowGroupIndices of the matrix. Must be nullptr if TrivialRowGrouping is true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The reference to the row group indices (either of the matrix or the given pointer) must not be invalidated as long as this operator is used. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00082">82</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<a id="a24153a9da75f8b3898825fa3a3192099" name="a24153a9da75f8b3898825fa3a3192099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24153a9da75f8b3898825fa3a3192099">&#9670;&#160;</a></span>unsetIgnoredRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , bool TrivialRowGrouping, typename SolutionType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">storm::solver::helper::ValueIterationOperator</a>&lt; ValueType, TrivialRowGrouping, SolutionType &gt;::unsetIgnoredRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all ignored rows. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html#l00094">94</a> of file <a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/storm/solver/helper/<a class="el" href="../../d7/d1b/_value_iteration_operator_8h_source.html">ValueIterationOperator.h</a></li>
<li>src/storm/solver/helper/<a class="el" href="../../d6/dab/_value_iteration_operator_8cpp_source.html">ValueIterationOperator.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../db/d5a/namespacestorm.html">storm</a></li><li class="navelem"><a class="el" href="../../df/ddc/namespacestorm_1_1solver.html">solver</a></li><li class="navelem"><a class="el" href="../../d3/d42/namespacestorm_1_1solver_1_1helper.html">helper</a></li><li class="navelem"><a class="el" href="../../d8/d02/classstorm_1_1solver_1_1helper_1_1_value_iteration_operator.html">ValueIterationOperator</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
